
#include "WHEncrypt.h"
#include "WHHead.h"

#ifdef WIN32

#else

#include <boost/uuid/uuid.hpp>
#include <uuid/uuid_generators.hpp>
#include <numeric/conversion/cast.hpp>
using namespace boost::uuids;

#endif

#define S_VER						0x66								//网络版本
/*
//加密密钥
const DWORD g_dwPacketKey=0xA55AA55A;

//发送映射
const BYTE g_SendByteMap[256]=
{
	0x70,0x2F,0x40,0x5F,0x44,0x8E,0x6E,0x45,0x7E,0xAB,0x2C,0x1F,0xB4,0xAC,0x9D,0x91,
	0x0D,0x36,0x9B,0x0B,0xD4,0xC4,0x39,0x74,0xBF,0x23,0x16,0x14,0x06,0xEB,0x04,0x3E,
	0x12,0x5C,0x8B,0xBC,0x61,0x63,0xF6,0xA5,0xE1,0x65,0xD8,0xF5,0x5A,0x07,0xF0,0x13,
	0xF2,0x20,0x6B,0x4A,0x24,0x59,0x89,0x64,0xD7,0x42,0x6A,0x5E,0x3D,0x0A,0x77,0xE0,
	0x80,0x27,0xB8,0xC5,0x8C,0x0E,0xFA,0x8A,0xD5,0x29,0x56,0x57,0x6C,0x53,0x67,0x41,
	0xE8,0x00,0x1A,0xCE,0x86,0x83,0xB0,0x22,0x28,0x4D,0x3F,0x26,0x46,0x4F,0x6F,0x2B,
	0x72,0x3A,0xF1,0x8D,0x97,0x95,0x49,0x84,0xE5,0xE3,0x79,0x8F,0x51,0x10,0xA8,0x82,
	0xC6,0xDD,0xFF,0xFC,0xE4,0xCF,0xB3,0x09,0x5D,0xEA,0x9C,0x34,0xF9,0x17,0x9F,0xDA,
	0x87,0xF8,0x15,0x05,0x3C,0xD3,0xA4,0x85,0x2E,0xFB,0xEE,0x47,0x3B,0xEF,0x37,0x7F,
	0x93,0xAF,0x69,0x0C,0x71,0x31,0xDE,0x21,0x75,0xA0,0xAA,0xBA,0x7C,0x38,0x02,0xB7,
	0x81,0x01,0xFD,0xE7,0x1D,0xCC,0xCD,0xBD,0x1B,0x7A,0x2A,0xAD,0x66,0xBE,0x55,0x33,
	0x03,0xDB,0x88,0xB2,0x1E,0x4E,0xB9,0xE6,0xC2,0xF7,0xCB,0x7D,0xC9,0x62,0xC3,0xA6,
	0xDC,0xA7,0x50,0xB5,0x4B,0x94,0xC0,0x92,0x4C,0x11,0x5B,0x78,0xD9,0xB1,0xED,0x19,
	0xE9,0xA1,0x1C,0xB6,0x32,0x99,0xA3,0x76,0x9E,0x7B,0x6D,0x9A,0x30,0xD6,0xA9,0x25,
	0xC7,0xAE,0x96,0x35,0xD0,0xBB,0xD2,0xC8,0xA2,0x08,0xF3,0xD1,0x73,0xF4,0x48,0x2D,
	0x90,0xCA,0xE2,0x58,0xC1,0x18,0x52,0xFE,0xDF,0x68,0x98,0x54,0xEC,0x60,0x43,0x0F
};

//接收映射
const BYTE g_RecvByteMap[256]=
{
	0x51,0xA1,0x9E,0xB0,0x1E,0x83,0x1C,0x2D,0xE9,0x77,0x3D,0x13,0x93,0x10,0x45,0xFF,
	0x6D,0xC9,0x20,0x2F,0x1B,0x82,0x1A,0x7D,0xF5,0xCF,0x52,0xA8,0xD2,0xA4,0xB4,0x0B,
	0x31,0x97,0x57,0x19,0x34,0xDF,0x5B,0x41,0x58,0x49,0xAA,0x5F,0x0A,0xEF,0x88,0x01,
	0xDC,0x95,0xD4,0xAF,0x7B,0xE3,0x11,0x8E,0x9D,0x16,0x61,0x8C,0x84,0x3C,0x1F,0x5A,
	0x02,0x4F,0x39,0xFE,0x04,0x07,0x5C,0x8B,0xEE,0x66,0x33,0xC4,0xC8,0x59,0xB5,0x5D,
	0xC2,0x6C,0xF6,0x4D,0xFB,0xAE,0x4A,0x4B,0xF3,0x35,0x2C,0xCA,0x21,0x78,0x3B,0x03,
	0xFD,0x24,0xBD,0x25,0x37,0x29,0xAC,0x4E,0xF9,0x92,0x3A,0x32,0x4C,0xDA,0x06,0x5E,
	0x00,0x94,0x60,0xEC,0x17,0x98,0xD7,0x3E,0xCB,0x6A,0xA9,0xD9,0x9C,0xBB,0x08,0x8F,
	0x40,0xA0,0x6F,0x55,0x67,0x87,0x54,0x80,0xB2,0x36,0x47,0x22,0x44,0x63,0x05,0x6B,
	0xF0,0x0F,0xC7,0x90,0xC5,0x65,0xE2,0x64,0xFA,0xD5,0xDB,0x12,0x7A,0x0E,0xD8,0x7E,
	0x99,0xD1,0xE8,0xD6,0x86,0x27,0xBF,0xC1,0x6E,0xDE,0x9A,0x09,0x0D,0xAB,0xE1,0x91,
	0x56,0xCD,0xB3,0x76,0x0C,0xC3,0xD3,0x9F,0x42,0xB6,0x9B,0xE5,0x23,0xA7,0xAD,0x18,
	0xC6,0xF4,0xB8,0xBE,0x15,0x43,0x70,0xE0,0xE7,0xBC,0xF1,0xBA,0xA5,0xA6,0x53,0x75,
	0xE4,0xEB,0xE6,0x85,0x14,0x48,0xDD,0x38,0x2A,0xCC,0x7F,0xB1,0xC0,0x71,0x96,0xF8,
	0x3F,0x28,0xF2,0x69,0x74,0x68,0xB7,0xA3,0x50,0xD0,0x79,0x1D,0xFC,0xCE,0x8A,0x8D,
	0x2E,0x62,0x30,0xEA,0xED,0x2B,0x26,0xB9,0x81,0x7C,0x46,0x89,0x73,0xA2,0xF7,0x72
};
*/

const DWORD g_dwPacketKey=0xFE2837AD;

//发送映射
const BYTE g_SendByteMap[256]=
{
	0x65,0x1B,0x5C,0xE1,0x6D,0xC0,0xF5,0x19,0x55,0x9D,0x22,0x44,0xA7,0x71,0xD5,0xF2,
	0x68,0xCC,0xDD,0x0D,0x14,0x46,0xB8,0xA8,0x11,0x52,0x31,0x85,0x13,0x78,0x15,0x63,
	0xD8,0x8D,0x0E,0xFB,0x30,0x51,0x5E,0xE5,0xAF,0x90,0x17,0xB6,0x62,0x8A,0xC7,0x0A,
	0x8E,0xE4,0x10,0xCD,0xE0,0x0C,0xF4,0xD0,0x70,0x6F,0xBC,0x98,0x9F,0x76,0x34,0xDC,
	0x24,0x06,0xE2,0x39,0x4D,0x20,0x9C,0xFF,0xDE,0x58,0x9B,0x26,0xDA,0x25,0x03,0x42,
	0x12,0xD3,0xFE,0xB1,0xDB,0x7C,0x21,0x7A,0x27,0x4A,0xE6,0x3E,0xAB,0x07,0xA6,0x67,
	0x32,0xF3,0x41,0xCB,0x3D,0xD1,0x0F,0x88,0xED,0x59,0xAD,0xEF,0x91,0xA1,0xF0,0xAC,
	0x2C,0xCE,0x3B,0x02,0xF8,0x79,0xEE,0x2E,0xE9,0x2A,0x1E,0x2F,0xEA,0x96,0x16,0xCA,
	0x6A,0xA3,0xFD,0x45,0x3C,0x7B,0xC5,0x8C,0xEB,0xEC,0xDF,0x4C,0x66,0xC4,0xB3,0x56,
	0x64,0x5D,0xA0,0x99,0x93,0xD6,0xBE,0xC9,0xBF,0x7D,0x5A,0xA4,0x1C,0xB2,0xC1,0xC6,
	0x33,0x6B,0x47,0x7E,0x4E,0x74,0x2D,0x1F,0xFC,0x8B,0x09,0xAA,0x8F,0x86,0x4B,0x9A,
	0x75,0x69,0x50,0x57,0x7F,0x3A,0x97,0x37,0xB0,0xB7,0xC2,0xBD,0x43,0xB9,0x18,0x92,
	0x36,0xF6,0x0B,0xB4,0xB5,0xA9,0x38,0x29,0xF9,0xD9,0x6E,0x48,0xF1,0x00,0x80,0xAE,
	0x53,0x6C,0xBA,0x83,0xFA,0x82,0x1D,0x35,0x89,0xC3,0x77,0x28,0xD4,0x9E,0x4F,0xE8,
	0x2B,0x3F,0x73,0x61,0xCF,0x60,0xF7,0x04,0x95,0xC8,0x72,0x81,0xD7,0xA2,0x49,0x94,
	0x54,0x5F,0x05,0x23,0x08,0xD2,0x01,0x1A,0x5B,0xBB,0xE3,0x84,0xA5,0x40,0xE7,0x87

};

//接收映射
const BYTE g_RecvByteMap[256]=
{
	0xCD,0xF6,0x73,0x4E,0xE7,0xF2,0x41,0x5D,0xF4,0xAA,0x2F,0xC2,0x35,0x13,0x22,0x66,
	0x32,0x18,0x50,0x1C,0x14,0x1E,0x7E,0x2A,0xBE,0x07,0xF7,0x01,0x9C,0xD6,0x7A,0xA7,
	0x45,0x56,0x0A,0xF3,0x40,0x4D,0x4B,0x58,0xDB,0xC7,0x79,0xE0,0x70,0xA6,0x77,0x7B,
	0x24,0x1A,0x60,0xA0,0x3E,0xD7,0xC0,0xB7,0xC6,0x43,0xB5,0x72,0x84,0x64,0x5B,0xE1,
	0xFD,0x62,0x4F,0xBC,0x0B,0x83,0x15,0xA2,0xCB,0xEE,0x59,0xAE,0x8B,0x44,0xA4,0xDE,
	0xB2,0x25,0x19,0xD0,0xF0,0x08,0x8F,0xB3,0x49,0x69,0x9A,0xF8,0x02,0x91,0x26,0xF1,
	0xE5,0xE3,0x2C,0x1F,0x90,0x00,0x8C,0x5F,0x10,0xB1,0x80,0xA1,0xD1,0x04,0xCA,0x39,
	0x38,0x0D,0xEA,0xE2,0xA5,0xB0,0x3D,0xDA,0x1D,0x75,0x57,0x85,0x55,0x99,0xA3,0xB4,
	0xCE,0xEB,0xD5,0xD3,0xFB,0x1B,0xAD,0xFF,0x67,0xD8,0x2D,0xA9,0x87,0x21,0x30,0xAC,
	0x29,0x6C,0xBF,0x94,0xEF,0xE8,0x7D,0xB6,0x3B,0x93,0xAF,0x4A,0x46,0x09,0xDD,0x3C,
	0x92,0x6D,0xED,0x81,0x9B,0xFC,0x5E,0x0C,0x17,0xC5,0xAB,0x5C,0x6F,0x6A,0xCF,0x28,
	0xB8,0x53,0x9D,0x8E,0xC3,0xC4,0x2B,0xB9,0x16,0xBD,0xD2,0xF9,0x3A,0xBB,0x96,0x98,
	0x05,0x9E,0xBA,0xD9,0x8D,0x86,0x9F,0x2E,0xE9,0x97,0x7F,0x63,0x11,0x33,0x71,0xE4,
	0x37,0x65,0xF5,0x51,0xDC,0x0E,0x95,0xEC,0x20,0xC9,0x4C,0x54,0x3F,0x12,0x48,0x8A,
	0x34,0x03,0x42,0xFA,0x31,0x27,0x5A,0xFE,0xDF,0x78,0x7C,0x88,0x89,0x68,0x76,0x6B,
	0x6E,0xCC,0x0F,0x61,0x36,0x06,0xC1,0xE6,0x74,0xC8,0xD4,0x23,0xA8,0x82,0x52,0x47
};


//加密数据
WORD CEncrypt::EncryptBuffer(int tag,BYTE pcbDataBuffer[], WORD wDataSize, WORD wBufferSize)
{

	SocketKey* key = mKeyMap[tag];
	//效验参数
	assert(wDataSize>=sizeof(CMD_Head));
	assert(wBufferSize>=(wDataSize+sizeof(CMD_Head)));

	//调整长度
	WORD wEncryptSize=wDataSize-sizeof(CMD_Command),wSnapCount=0;
	if ((wEncryptSize%sizeof(DWORD))!=0)
	{
		wSnapCount=sizeof(DWORD)-wEncryptSize%sizeof(DWORD);
		memset(pcbDataBuffer+sizeof(CMD_Info)+wEncryptSize,0,wSnapCount);
	}

	CMD_Head* phead=(CMD_Head*)pcbDataBuffer;	

	//效验码与字节映射
	BYTE cbCheckCode=0;
	for (WORD i=sizeof(CMD_Info);i<wDataSize;i++)
	{
		cbCheckCode+=pcbDataBuffer[i];
		pcbDataBuffer[i]=MapSendByte(tag,pcbDataBuffer[i]);
	}

	//填写信息头
	CMD_Head * pHead=(CMD_Head *)pcbDataBuffer;
	pHead->CmdInfo.cbCheckCode=~cbCheckCode+1;

	//CCLOG("cbCheckCode=%d pHead->CmdInfo.cbCheckCode=%d",cbCheckCode,pHead->CmdInfo.cbCheckCode);

	//创建密钥
	DWORD dwXorKey = key->m_dwSendXorKey;
	if (key->m_dwSendPacketCount == 0)
	{
		GUID Guid;

#ifdef WIN32		
		CoCreateGuid(&Guid);
#else
		boost::uuids::random_generator generator;
		boost::uuids::uuid buuid = generator();

		buuid.data[0] &= 127;
		buuid.data[4] &= 127;
		buuid.data[6] &= 127;

		Guid.Data1 = boost::numeric_cast<unsigned long>((buuid.data[0] << 24) + (buuid.data[1] << 16) + (buuid.data[2] << 8) + buuid.data[3]);
		Guid.Data2 = boost::numeric_cast<unsigned short>((buuid.data[4] << 8) + buuid.data[5]);
		Guid.Data3 = boost::numeric_cast<unsigned short>((buuid.data[6] << 8) + buuid.data[7]);
		for (size_t i = 0; 8 > i; ++i)
		{
			buuid.data[i+8] &= 127;

			Guid.Data4[i] = boost::numeric_cast<unsigned char>(buuid.data[i+8]);
		}
#endif

#ifdef WIN32
		dwXorKey=GetTickCount()*GetTickCount();
#else
		dwXorKey = 1234567800;
#endif
		dwXorKey^=Guid.Data1;
		dwXorKey^=Guid.Data2;
		dwXorKey^=Guid.Data3;
		dwXorKey^=*((DWORD *)Guid.Data4);

		//随机映射种子
		dwXorKey=SeedRandMap(tag,(WORD)dwXorKey);
		dwXorKey|=((DWORD)SeedRandMap(tag,(WORD)(dwXorKey>>16)))<<16;

		dwXorKey^=g_dwPacketKey;

		key->m_dwSendXorKey = dwXorKey;
		key->m_dwRecvXorKey = dwXorKey;
	}

	//加密数据
	WORD * pwSeed=(WORD *)(pcbDataBuffer+sizeof(CMD_Info));
	DWORD * pdwXor=(DWORD *)(pcbDataBuffer+sizeof(CMD_Info));
	WORD wEncrypCount=(wEncryptSize+wSnapCount)/sizeof(DWORD);

	for (int i=0;i<wEncrypCount;i++)
	{
		*pdwXor++^=dwXorKey;
		dwXorKey=SeedRandMap(tag,*pwSeed++);
		dwXorKey|=((DWORD)SeedRandMap(tag,*pwSeed++))<<16;
		dwXorKey^=g_dwPacketKey;
	}

	//插入密钥
	if (key->m_dwSendPacketCount == 0)
	{		
		memmove(pcbDataBuffer+sizeof(CMD_Head)+sizeof(DWORD),pcbDataBuffer+sizeof(CMD_Head),wDataSize);
		*((DWORD *)(pcbDataBuffer + sizeof(CMD_Head))) = key->m_dwSendXorKey;
		pHead->CmdInfo.wPacketSize+=sizeof(DWORD);
		wDataSize+=sizeof(DWORD);		
	}

	//设置变量
	key->m_dwSendPacketCount++;
	key->m_dwSendXorKey = dwXorKey;

	return wDataSize;
}



//解密数据
WORD CEncrypt::DecryptBuffer(int tag, BYTE pcbDataBuffer[], WORD wDataSize)
{
	//调整长度
	WORD wSnapCount=0;
	if ((wDataSize%sizeof(DWORD))!=0)
	{
		wSnapCount=sizeof(DWORD)-wDataSize%sizeof(DWORD);
		memset(pcbDataBuffer+wDataSize,0,wSnapCount);
	}

	//解密数据
	DWORD dwXorKey=mKeyMap[tag]->m_dwRecvXorKey;
	DWORD * pdwXor=(DWORD *)(pcbDataBuffer+sizeof(CMD_Info));
	WORD  * pwSeed=(WORD *)(pcbDataBuffer+sizeof(CMD_Info));
	WORD wEncrypCount=(wDataSize+wSnapCount-sizeof(CMD_Info))/4;
	for (WORD i=0;i<wEncrypCount;i++)
	{
		if ((i==(wEncrypCount-1))&&(wSnapCount>0))
		{
			BYTE * pcbKey=((BYTE *)&mKeyMap[tag]->m_dwRecvXorKey)+sizeof(DWORD)-wSnapCount;
			//CopyMemory(pcbDataBuffer+wDataSize,pcbKey,wSnapCount);
			memcpy(pcbDataBuffer+wDataSize,pcbKey,wSnapCount);
		}
		dwXorKey=SeedRandMap(tag,*pwSeed++);
		dwXorKey|=((DWORD)SeedRandMap(tag,*pwSeed++))<<16;
		dwXorKey^=g_dwPacketKey;
		*pdwXor++^=mKeyMap[tag]->m_dwRecvXorKey;
		mKeyMap[tag]->m_dwRecvXorKey=dwXorKey;
	}

	//效验码与字节映射
	CMD_Head * pHead=(CMD_Head *)pcbDataBuffer;
	BYTE cbCheckCode=pHead->CmdInfo.cbCheckCode;
	for (int i=sizeof(CMD_Info);i<wDataSize;i++)
	{
		pcbDataBuffer[i]=MapRecvByte(tag,pcbDataBuffer[i]);
		cbCheckCode+=pcbDataBuffer[i];
	}
	if (cbCheckCode!=0) {
		CCLOG("CHECKCODE IS NOT ZERO");
		return 0;
	}
	return wDataSize;
}


BYTE CEncrypt::MapRecvByte(int tag,BYTE const cbData)
{
	BYTE cbMap=g_RecvByteMap[cbData]-mKeyMap[tag]->m_cbRecvRound;
	mKeyMap[tag]->m_cbRecvRound+=3;
	return cbMap;
}

BYTE CEncrypt::MapSendByte(int tag,BYTE const cbData)
{	
	BYTE offset = mKeyMap[tag]->m_cbSendRound;
	BYTE cbMap = g_SendByteMap[(BYTE)(cbData + offset)];
	mKeyMap[tag]->m_cbSendRound+=3;
	return cbMap;
}

//随机映射
WORD CEncrypt::SeedRandMap(int tag,WORD wSeed)
{
	DWORD dwHold=wSeed;
	return (WORD)((dwHold=dwHold*241103L+2533101L)>>16);
}

void CEncrypt::ResetFlags()
{
	map<int,SocketKey*>::iterator it=mKeyMap.begin();
	while(it!=mKeyMap.end())
	{
		this->ResetFlags(it->first);
	}
}

void CEncrypt::ResetFlags( int tag )
{
	if(tag<0||mKeyMap[tag]==NULL) return;
	mKeyMap[tag]->m_cbSendRound = 0;
	mKeyMap[tag]->m_cbRecvRound = 0;
	mKeyMap[tag]->m_dwSendXorKey = 0;
	mKeyMap[tag]->m_dwRecvXorKey = 0;
	mKeyMap[tag]->m_dwSendPacketCount = 0;
	mKeyMap[tag]->m_dwRecvPacketCount = 0;
	CCLOG("CEncrypt::ResetFlags %d",tag);
}

CEncrypt::~CEncrypt()
{
	this->ClearKeys();
}

CEncrypt::CEncrypt()
{
	ResetFlags();
}

SocketKey* CEncrypt::isKeyExists( int tag )
{
	map<int,SocketKey*>::iterator it=mKeyMap.begin();
	while(it!=mKeyMap.end())
	{
		if(it->first==tag)
			return it->second;
		it++;
	}
	return NULL;
}

SocketKey* CEncrypt::addOrGetKey( int tag )
{
	SocketKey* os=isKeyExists(tag);
	if(NULL==os||NULL==mKeyMap[tag])
	{
		SocketKey *s = new SocketKey();
		s->m_cbRecvRound = 0;
		s->m_cbSendRound = 0;
		s->m_dwRecvPacketCount = 0;
		s->m_dwSendPacketCount = 0;
		s->m_dwRecvXorKey = 0;
		s->m_dwSendXorKey = 0;
		mKeyMap[tag]=s;
		return s;
	}else
	{
		return os;
	}
}

void CEncrypt::ClearKeys()
{
	map<int,SocketKey*>::iterator it=mKeyMap.begin();
	while(it!=mKeyMap.end())
	{
		delete it->second;
		mKeyMap.erase(it++);
	}
	mKeyMap.clear();
}

void CEncrypt::RemoveKey( int tag )
{
	map<int,SocketKey*>::iterator it=mKeyMap.begin();
	while(it!=mKeyMap.end())
	{
		if(it->first==tag)
		{
			delete it->second;
			mKeyMap.erase(it++);
		}else
			++it;
	}	
}
