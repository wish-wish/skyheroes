// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CacheInfo.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CacheInfo.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace sunMap {

namespace {

const ::google::protobuf::Descriptor* CacheTile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CacheTile_reflection_ = NULL;
const ::google::protobuf::Descriptor* LodInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LodInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* LodInfos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LodInfos_reflection_ = NULL;
const ::google::protobuf::Descriptor* Bounds_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Bounds_reflection_ = NULL;
const ::google::protobuf::Descriptor* CacheInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CacheInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CacheInfo_2eproto() {
  protobuf_AddDesc_CacheInfo_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CacheInfo.proto");
  GOOGLE_CHECK(file != NULL);
  CacheTile_descriptor_ = file->message_type(0);
  static const int CacheTile_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheTile, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheTile, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheTile, z_),
  };
  CacheTile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CacheTile_descriptor_,
      CacheTile::default_instance_,
      CacheTile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheTile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheTile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CacheTile));
  LodInfo_descriptor_ = file->message_type(1);
  static const int LodInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, numtile2need_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, tilelost_),
  };
  LodInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LodInfo_descriptor_,
      LodInfo::default_instance_,
      LodInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LodInfo));
  LodInfos_descriptor_ = file->message_type(2);
  static const int LodInfos_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, numlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, numtile2need_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, numtileindisk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, lodinfos_),
  };
  LodInfos_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LodInfos_descriptor_,
      LodInfos::default_instance_,
      LodInfos_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LodInfos, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LodInfos));
  Bounds_descriptor_ = file->message_type(3);
  static const int Bounds_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, bottom_),
  };
  Bounds_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Bounds_descriptor_,
      Bounds::default_instance_,
      Bounds_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bounds, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Bounds));
  CacheInfo_descriptor_ = file->message_type(4);
  static const int CacheInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, bound_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, mapid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, imagetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, lods_),
  };
  CacheInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CacheInfo_descriptor_,
      CacheInfo::default_instance_,
      CacheInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CacheInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CacheInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CacheInfo_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CacheTile_descriptor_, &CacheTile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LodInfo_descriptor_, &LodInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LodInfos_descriptor_, &LodInfos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Bounds_descriptor_, &Bounds::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CacheInfo_descriptor_, &CacheInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CacheInfo_2eproto() {
  delete CacheTile::default_instance_;
  delete CacheTile_reflection_;
  delete LodInfo::default_instance_;
  delete LodInfo_reflection_;
  delete LodInfos::default_instance_;
  delete LodInfos_reflection_;
  delete Bounds::default_instance_;
  delete Bounds_reflection_;
  delete CacheInfo::default_instance_;
  delete CacheInfo_reflection_;
}

void protobuf_AddDesc_CacheInfo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017CacheInfo.proto\022\006sunMap\",\n\tCacheTile\022\t"
    "\n\001x\030\001 \002(\r\022\t\n\001y\030\002 \002(\r\022\t\n\001z\030\003 \002(\r\"b\n\007LodIn"
    "fo\022\r\n\005level\030\001 \002(\005\022\r\n\005scale\030\002 \001(\002\022\024\n\014numT"
    "ile2Need\030\003 \002(\005\022#\n\010tileLost\030\004 \003(\0132\021.sunMa"
    "p.CacheTile\"l\n\010LodInfos\022\020\n\010numLevel\030\001 \002("
    "\005\022\024\n\014numTile2Need\030\002 \002(\005\022\025\n\rnumTileInDisk"
    "\030\003 \002(\005\022!\n\010lodInfos\030\004 \003(\0132\017.sunMap.LodInf"
    "o\"B\n\006Bounds\022\014\n\004left\030\001 \002(\002\022\013\n\003top\030\002 \002(\002\022\r"
    "\n\005right\030\003 \002(\002\022\016\n\006bottom\030\004 \002(\002\"\210\001\n\tCacheI"
    "nfo\022\014\n\004name\030\001 \002(\t\022\035\n\005bound\030\002 \002(\0132\016.sunMa"
    "p.Bounds\022\r\n\005mapId\030\003 \002(\014\022\021\n\timageType\030\004 \002"
    "(\014\022\014\n\004time\030\005 \002(\002\022\036\n\004lods\030\006 \002(\0132\020.sunMap."
    "LodInfos", 488);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CacheInfo.proto", &protobuf_RegisterTypes);
  CacheTile::default_instance_ = new CacheTile();
  LodInfo::default_instance_ = new LodInfo();
  LodInfos::default_instance_ = new LodInfos();
  Bounds::default_instance_ = new Bounds();
  CacheInfo::default_instance_ = new CacheInfo();
  CacheTile::default_instance_->InitAsDefaultInstance();
  LodInfo::default_instance_->InitAsDefaultInstance();
  LodInfos::default_instance_->InitAsDefaultInstance();
  Bounds::default_instance_->InitAsDefaultInstance();
  CacheInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CacheInfo_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CacheInfo_2eproto {
  StaticDescriptorInitializer_CacheInfo_2eproto() {
    protobuf_AddDesc_CacheInfo_2eproto();
  }
} static_descriptor_initializer_CacheInfo_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int CacheTile::kXFieldNumber;
const int CacheTile::kYFieldNumber;
const int CacheTile::kZFieldNumber;
#endif  // !_MSC_VER

CacheTile::CacheTile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CacheTile::InitAsDefaultInstance() {
}

CacheTile::CacheTile(const CacheTile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CacheTile::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0u;
  y_ = 0u;
  z_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CacheTile::~CacheTile() {
  SharedDtor();
}

void CacheTile::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CacheTile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CacheTile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CacheTile_descriptor_;
}

const CacheTile& CacheTile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CacheInfo_2eproto();
  return *default_instance_;
}

CacheTile* CacheTile::default_instance_ = NULL;

CacheTile* CacheTile::New() const {
  return new CacheTile;
}

void CacheTile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0u;
    y_ = 0u;
    z_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CacheTile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required uint32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_z;
        break;
      }

      // required uint32 z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CacheTile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->x(), output);
  }

  // required uint32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->y(), output);
  }

  // required uint32 z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CacheTile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->x(), target);
  }

  // required uint32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->y(), target);
  }

  // required uint32 z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CacheTile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // required uint32 z = 3;
    if (has_z()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->z());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CacheTile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CacheTile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CacheTile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CacheTile::MergeFrom(const CacheTile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CacheTile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CacheTile::CopyFrom(const CacheTile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheTile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CacheTile::Swap(CacheTile* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CacheTile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CacheTile_descriptor_;
  metadata.reflection = CacheTile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LodInfo::kLevelFieldNumber;
const int LodInfo::kScaleFieldNumber;
const int LodInfo::kNumTile2NeedFieldNumber;
const int LodInfo::kTileLostFieldNumber;
#endif  // !_MSC_VER

LodInfo::LodInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LodInfo::InitAsDefaultInstance() {
}

LodInfo::LodInfo(const LodInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LodInfo::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0;
  scale_ = 0;
  numtile2need_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LodInfo::~LodInfo() {
  SharedDtor();
}

void LodInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LodInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LodInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LodInfo_descriptor_;
}

const LodInfo& LodInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CacheInfo_2eproto();
  return *default_instance_;
}

LodInfo* LodInfo::default_instance_ = NULL;

LodInfo* LodInfo::New() const {
  return new LodInfo;
}

void LodInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0;
    scale_ = 0;
    numtile2need_ = 0;
  }
  tilelost_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LodInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_scale;
        break;
      }

      // optional float scale = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_numTile2Need;
        break;
      }

      // required int32 numTile2Need = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numTile2Need:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numtile2need_)));
          set_has_numtile2need();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tileLost;
        break;
      }

      // repeated .sunMap.CacheTile tileLost = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tileLost:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tilelost()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tileLost;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LodInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->level(), output);
  }

  // optional float scale = 2;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->scale(), output);
  }

  // required int32 numTile2Need = 3;
  if (has_numtile2need()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->numtile2need(), output);
  }

  // repeated .sunMap.CacheTile tileLost = 4;
  for (int i = 0; i < this->tilelost_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->tilelost(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LodInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 level = 1;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->level(), target);
  }

  // optional float scale = 2;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->scale(), target);
  }

  // required int32 numTile2Need = 3;
  if (has_numtile2need()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->numtile2need(), target);
  }

  // repeated .sunMap.CacheTile tileLost = 4;
  for (int i = 0; i < this->tilelost_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->tilelost(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LodInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional float scale = 2;
    if (has_scale()) {
      total_size += 1 + 4;
    }

    // required int32 numTile2Need = 3;
    if (has_numtile2need()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numtile2need());
    }

  }
  // repeated .sunMap.CacheTile tileLost = 4;
  total_size += 1 * this->tilelost_size();
  for (int i = 0; i < this->tilelost_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tilelost(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LodInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LodInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LodInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LodInfo::MergeFrom(const LodInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  tilelost_.MergeFrom(from.tilelost_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_numtile2need()) {
      set_numtile2need(from.numtile2need());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LodInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LodInfo::CopyFrom(const LodInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LodInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  for (int i = 0; i < tilelost_size(); i++) {
    if (!this->tilelost(i).IsInitialized()) return false;
  }
  return true;
}

void LodInfo::Swap(LodInfo* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(scale_, other->scale_);
    std::swap(numtile2need_, other->numtile2need_);
    tilelost_.Swap(&other->tilelost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LodInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LodInfo_descriptor_;
  metadata.reflection = LodInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LodInfos::kNumLevelFieldNumber;
const int LodInfos::kNumTile2NeedFieldNumber;
const int LodInfos::kNumTileInDiskFieldNumber;
const int LodInfos::kLodInfosFieldNumber;
#endif  // !_MSC_VER

LodInfos::LodInfos()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LodInfos::InitAsDefaultInstance() {
}

LodInfos::LodInfos(const LodInfos& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LodInfos::SharedCtor() {
  _cached_size_ = 0;
  numlevel_ = 0;
  numtile2need_ = 0;
  numtileindisk_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LodInfos::~LodInfos() {
  SharedDtor();
}

void LodInfos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LodInfos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LodInfos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LodInfos_descriptor_;
}

const LodInfos& LodInfos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CacheInfo_2eproto();
  return *default_instance_;
}

LodInfos* LodInfos::default_instance_ = NULL;

LodInfos* LodInfos::New() const {
  return new LodInfos;
}

void LodInfos::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    numlevel_ = 0;
    numtile2need_ = 0;
    numtileindisk_ = 0;
  }
  lodinfos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LodInfos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 numLevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numlevel_)));
          set_has_numlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_numTile2Need;
        break;
      }

      // required int32 numTile2Need = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numTile2Need:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numtile2need_)));
          set_has_numtile2need();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_numTileInDisk;
        break;
      }

      // required int32 numTileInDisk = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numTileInDisk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numtileindisk_)));
          set_has_numtileindisk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_lodInfos;
        break;
      }

      // repeated .sunMap.LodInfo lodInfos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lodInfos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lodinfos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_lodInfos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LodInfos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 numLevel = 1;
  if (has_numlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->numlevel(), output);
  }

  // required int32 numTile2Need = 2;
  if (has_numtile2need()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->numtile2need(), output);
  }

  // required int32 numTileInDisk = 3;
  if (has_numtileindisk()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->numtileindisk(), output);
  }

  // repeated .sunMap.LodInfo lodInfos = 4;
  for (int i = 0; i < this->lodinfos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->lodinfos(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LodInfos::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 numLevel = 1;
  if (has_numlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->numlevel(), target);
  }

  // required int32 numTile2Need = 2;
  if (has_numtile2need()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->numtile2need(), target);
  }

  // required int32 numTileInDisk = 3;
  if (has_numtileindisk()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->numtileindisk(), target);
  }

  // repeated .sunMap.LodInfo lodInfos = 4;
  for (int i = 0; i < this->lodinfos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->lodinfos(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LodInfos::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 numLevel = 1;
    if (has_numlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numlevel());
    }

    // required int32 numTile2Need = 2;
    if (has_numtile2need()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numtile2need());
    }

    // required int32 numTileInDisk = 3;
    if (has_numtileindisk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numtileindisk());
    }

  }
  // repeated .sunMap.LodInfo lodInfos = 4;
  total_size += 1 * this->lodinfos_size();
  for (int i = 0; i < this->lodinfos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lodinfos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LodInfos::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LodInfos* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LodInfos*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LodInfos::MergeFrom(const LodInfos& from) {
  GOOGLE_CHECK_NE(&from, this);
  lodinfos_.MergeFrom(from.lodinfos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_numlevel()) {
      set_numlevel(from.numlevel());
    }
    if (from.has_numtile2need()) {
      set_numtile2need(from.numtile2need());
    }
    if (from.has_numtileindisk()) {
      set_numtileindisk(from.numtileindisk());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LodInfos::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LodInfos::CopyFrom(const LodInfos& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LodInfos::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  for (int i = 0; i < lodinfos_size(); i++) {
    if (!this->lodinfos(i).IsInitialized()) return false;
  }
  return true;
}

void LodInfos::Swap(LodInfos* other) {
  if (other != this) {
    std::swap(numlevel_, other->numlevel_);
    std::swap(numtile2need_, other->numtile2need_);
    std::swap(numtileindisk_, other->numtileindisk_);
    lodinfos_.Swap(&other->lodinfos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LodInfos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LodInfos_descriptor_;
  metadata.reflection = LodInfos_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Bounds::kLeftFieldNumber;
const int Bounds::kTopFieldNumber;
const int Bounds::kRightFieldNumber;
const int Bounds::kBottomFieldNumber;
#endif  // !_MSC_VER

Bounds::Bounds()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Bounds::InitAsDefaultInstance() {
}

Bounds::Bounds(const Bounds& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Bounds::SharedCtor() {
  _cached_size_ = 0;
  left_ = 0;
  top_ = 0;
  right_ = 0;
  bottom_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Bounds::~Bounds() {
  SharedDtor();
}

void Bounds::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Bounds::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Bounds::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Bounds_descriptor_;
}

const Bounds& Bounds::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CacheInfo_2eproto();
  return *default_instance_;
}

Bounds* Bounds::default_instance_ = NULL;

Bounds* Bounds::New() const {
  return new Bounds;
}

void Bounds::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    left_ = 0;
    top_ = 0;
    right_ = 0;
    bottom_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Bounds::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float left = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_top;
        break;
      }

      // required float top = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_)));
          set_has_top();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_right;
        break;
      }

      // required float right = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_bottom;
        break;
      }

      // required float bottom = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bottom_)));
          set_has_bottom();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Bounds::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float left = 1;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->left(), output);
  }

  // required float top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->top(), output);
  }

  // required float right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->right(), output);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->bottom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Bounds::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float left = 1;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->left(), target);
  }

  // required float top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->top(), target);
  }

  // required float right = 3;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->right(), target);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->bottom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Bounds::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float left = 1;
    if (has_left()) {
      total_size += 1 + 4;
    }

    // required float top = 2;
    if (has_top()) {
      total_size += 1 + 4;
    }

    // required float right = 3;
    if (has_right()) {
      total_size += 1 + 4;
    }

    // required float bottom = 4;
    if (has_bottom()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bounds::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Bounds* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Bounds*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Bounds::MergeFrom(const Bounds& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_top()) {
      set_top(from.top());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
    if (from.has_bottom()) {
      set_bottom(from.bottom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Bounds::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bounds::CopyFrom(const Bounds& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bounds::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Bounds::Swap(Bounds* other) {
  if (other != this) {
    std::swap(left_, other->left_);
    std::swap(top_, other->top_);
    std::swap(right_, other->right_);
    std::swap(bottom_, other->bottom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Bounds::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Bounds_descriptor_;
  metadata.reflection = Bounds_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CacheInfo::kNameFieldNumber;
const int CacheInfo::kBoundFieldNumber;
const int CacheInfo::kMapIdFieldNumber;
const int CacheInfo::kImageTypeFieldNumber;
const int CacheInfo::kTimeFieldNumber;
const int CacheInfo::kLodsFieldNumber;
#endif  // !_MSC_VER

CacheInfo::CacheInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CacheInfo::InitAsDefaultInstance() {
  bound_ = const_cast< ::sunMap::Bounds*>(&::sunMap::Bounds::default_instance());
  lods_ = const_cast< ::sunMap::LodInfos*>(&::sunMap::LodInfos::default_instance());
}

CacheInfo::CacheInfo(const CacheInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CacheInfo::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bound_ = NULL;
  mapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  imagetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_ = 0;
  lods_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CacheInfo::~CacheInfo() {
  SharedDtor();
}

void CacheInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (mapid_ != &::google::protobuf::internal::kEmptyString) {
    delete mapid_;
  }
  if (imagetype_ != &::google::protobuf::internal::kEmptyString) {
    delete imagetype_;
  }
  if (this != default_instance_) {
    delete bound_;
    delete lods_;
  }
}

void CacheInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CacheInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CacheInfo_descriptor_;
}

const CacheInfo& CacheInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CacheInfo_2eproto();
  return *default_instance_;
}

CacheInfo* CacheInfo::default_instance_ = NULL;

CacheInfo* CacheInfo::New() const {
  return new CacheInfo;
}

void CacheInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_bound()) {
      if (bound_ != NULL) bound_->::sunMap::Bounds::Clear();
    }
    if (has_mapid()) {
      if (mapid_ != &::google::protobuf::internal::kEmptyString) {
        mapid_->clear();
      }
    }
    if (has_imagetype()) {
      if (imagetype_ != &::google::protobuf::internal::kEmptyString) {
        imagetype_->clear();
      }
    }
    time_ = 0;
    if (has_lods()) {
      if (lods_ != NULL) lods_->::sunMap::LodInfos::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CacheInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_bound;
        break;
      }

      // required .sunMap.Bounds bound = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bound:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bound()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_mapId;
        break;
      }

      // required bytes mapId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mapId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mapid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_imageType;
        break;
      }

      // required bytes imageType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imageType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_imagetype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_time;
        break;
      }

      // required float time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_lods;
        break;
      }

      // required .sunMap.LodInfos lods = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lods:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lods()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CacheInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required .sunMap.Bounds bound = 2;
  if (has_bound()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->bound(), output);
  }

  // required bytes mapId = 3;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->mapid(), output);
  }

  // required bytes imageType = 4;
  if (has_imagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->imagetype(), output);
  }

  // required float time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->time(), output);
  }

  // required .sunMap.LodInfos lods = 6;
  if (has_lods()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->lods(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CacheInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .sunMap.Bounds bound = 2;
  if (has_bound()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->bound(), target);
  }

  // required bytes mapId = 3;
  if (has_mapid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->mapid(), target);
  }

  // required bytes imageType = 4;
  if (has_imagetype()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->imagetype(), target);
  }

  // required float time = 5;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->time(), target);
  }

  // required .sunMap.LodInfos lods = 6;
  if (has_lods()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->lods(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CacheInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .sunMap.Bounds bound = 2;
    if (has_bound()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bound());
    }

    // required bytes mapId = 3;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mapid());
    }

    // required bytes imageType = 4;
    if (has_imagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->imagetype());
    }

    // required float time = 5;
    if (has_time()) {
      total_size += 1 + 4;
    }

    // required .sunMap.LodInfos lods = 6;
    if (has_lods()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lods());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CacheInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CacheInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CacheInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CacheInfo::MergeFrom(const CacheInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_bound()) {
      mutable_bound()->::sunMap::Bounds::MergeFrom(from.bound());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_imagetype()) {
      set_imagetype(from.imagetype());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_lods()) {
      mutable_lods()->::sunMap::LodInfos::MergeFrom(from.lods());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CacheInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CacheInfo::CopyFrom(const CacheInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_bound()) {
    if (!this->bound().IsInitialized()) return false;
  }
  if (has_lods()) {
    if (!this->lods().IsInitialized()) return false;
  }
  return true;
}

void CacheInfo::Swap(CacheInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(bound_, other->bound_);
    std::swap(mapid_, other->mapid_);
    std::swap(imagetype_, other->imagetype_);
    std::swap(time_, other->time_);
    std::swap(lods_, other->lods_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CacheInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CacheInfo_descriptor_;
  metadata.reflection = CacheInfo_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sunMap

// @@protoc_insertion_point(global_scope)
